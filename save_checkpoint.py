import importlib
import os
import numpy
import pandas
from pytorch_lightning.callbacks import ModelCheckpoint
import pytorch_lightning as pl
import shutil
from pytorch_lightning.utilities import rank_zero_info
from utils import zip_dir
import re


class SaveCheckpoint(ModelCheckpoint):
    def __init__(self,
                 config,
                 verbose=True,
                 no_save_before_epoch=0,
                 save_last=False):
        """
        The callback implements the checkpoint saving logic and defines on_validation_end in the callback function.
        通过回调实现checkpoint的保存逻辑, 同时具有回调函数中定义on_validation_end等功能.
        """
        imported = importlib.import_module('network.%(model_name)s' % config)
        evaluate = imported.Evaluate()
        monitor, monitor_mode = evaluate.evaluate[0].name, evaluate.evaluate[0].best_mode
        super().__init__(every_n_epochs=config['every_n_epochs'], verbose=verbose, mode=monitor_mode,
                         monitor='Validation ' + monitor, save_top_k=config['save_top_k'], save_last=save_last)
        self.config = config
        self.path_final_save = config['path_final_save']
        self.no_save_before_epoch = no_save_before_epoch
        if config['seed'] is not None:
            numpy.random.seed(config['seed'])
            self.seeds = numpy.random.randint(0, 2000, config['max_epochs'])
            pl.seed_everything(config['seed'])
            self.flag_sanity_check = 0

    def on_validation_end(self, trainer: 'pl.Trainer', pl_module: 'pl.LightningModule') -> None:
        """
        The random number logic is modified, the random seed of the network is given, and the random seed of the sample
        is generated by the given random seed, so as to ensure that each epoch has different sampling sequences
        even if overloaded training. And saving checkpoint.
        修改随机数逻辑,网络的随机种子给定,取样本的随机种子由给定的随机种子生成,保证即使重载训练每个epoch具有不同的抽样序列. 同时保存checkpoint.

        :param trainer:
        :param pl_module:
        :return:
        """
        # The first epoch used the raw input seed as the seed, and subsequent epochs used the first epoch-1 of
        # the seeds as the seed
        # 第一个epoch使用原始输入seed作为种子, 后续的epoch使用seeds中的第epoch-1个作为种子
        if self.config['seed'] is not None:
            if self.flag_sanity_check == 0:
                self.flag_sanity_check = 1
            else:
                pl.seed_everything(self.seeds[trainer.current_epoch])
        super().on_validation_end(trainer, pl_module)

    def _save_topk_checkpoint(self, trainer: 'pl.Trainer', monitor_candidates) -> None:
        epoch = monitor_candidates.get("epoch")
        version_name = self.get_version_name(self.dirpath)
        log_path = '/'.join(re.split(r'[/|\\]', self.dirpath)[0:2]) + '/'

        # period save
        if epoch >= self.no_save_before_epoch and self.config['saved_every_n_epochs'] != -1 and epoch % self.config[
            'saved_every_n_epochs'] == 0:
            filepath = self._get_metric_interpolated_filepath_name(monitor_candidates, trainer)
            self._save_checkpoint(trainer, filepath)

        if self.monitor is None or self.save_top_k == 0 or epoch < self.no_save_before_epoch:
            return

        current = monitor_candidates.get(self.monitor)

        if self.check_monitor_top_k(trainer, current):
            self._update_best_and_save(current, trainer, monitor_candidates)

            if self.mode == 'max':
                monitor_value = max([float('%.2f' % item) for item in list(self.best_k_models.values())])
            else:
                monitor_value = min([float('%.2f' % item) for item in list(self.best_k_models.values())])
            self.save_version_info(log_path, version_name, epoch, monitor_value)

            # After each update of the CKPT file, store it in a different location
            # 每次更新ckpt文件后, 将其存放到另一个位置
            if self.path_final_save is not None:
                zip_dir(log_path + version_name, './' + version_name + '.zip')
                if os.path.exists(self.path_final_save + '/' + version_name + '.zip'):
                    os.remove(self.path_final_save + '/' + version_name + '.zip')
                shutil.move('./' + version_name + '.zip', self.path_final_save)
        elif self.verbose:
            step = monitor_candidates.get("step")
            best_model_values = 'now best model:'
            for cou_best_model in self.best_k_models:
                best_model_values = ' '.join(
                    (best_model_values, str(round(float(self.best_k_models[cou_best_model]), 4))))
            rank_zero_info(
                f"\nEpoch {epoch:d}, global step {step:d}: {self.monitor} ({float(current):f}) was not in "
                f"top {self.save_top_k:d}({best_model_values:s})")

    def save_version_info(self, log_path, version_name, epoch, monitor_value):
        """
        Epoch 0 indicates that the epoch was not recorded or indeed 0, and epoch -1 indicates that
        this is the result of the test phase
        epoch为0表示未记录epoch或确实为0, epoch为-1表示这是测试阶段产生的结果
        """
        # The attributes of the version information table are:
        # version name, EPOCH or test results, evaluation results, remarks
        # the new info should be modified there
        # 版本信息表格的属性有: 版本名, epoch或测试结果, 评价结果, 备注
        # 新增的话修改此处
        saved_info = {'version_name': version_name, 'dataset_name': self.config['dataset_name'],
                      'model_name': self.config['model_name'], 'monitor': self.monitor,
                      'monitor_value': monitor_value, 'epoch': int(epoch), 'config': str(self.config)}
        pd_one = pandas.DataFrame([saved_info])
        if not os.path.exists(log_path + 'version_info.csv'):
            pd_one.to_csv(log_path + 'version_info.csv', index=False, encoding="utf-8")
        else:
            pd = pandas.read_csv(log_path + 'version_info.csv', encoding='utf-8')
            if version_name in pd['version_name'].tolist():
                pd[pd['version_name'] == version_name] = list(saved_info.values())
            else:
                pd = pandas.concat([pd, pd_one])
            pd.to_csv(log_path + 'version_info.csv', index=False, encoding="utf-8")

    @staticmethod
    def get_version_name(dirpath):
        version_name = 'version_unkown'
        for item in re.split(r'[/|\\]', dirpath):
            if 'version_' in item:
                version_name = item
                break
        return version_name
